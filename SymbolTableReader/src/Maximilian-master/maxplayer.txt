struct _IO_FILE {
	int                        _flags;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     _IO_read_ptr;         /*     8     8 */
	char *                     _IO_read_end;         /*    16     8 */
	char *                     _IO_read_base;        /*    24     8 */
	char *                     _IO_write_base;       /*    32     8 */
	char *                     _IO_write_ptr;        /*    40     8 */
	char *                     _IO_write_end;        /*    48     8 */
	char *                     _IO_buf_base;         /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     _IO_buf_end;          /*    64     8 */
	char *                     _IO_save_base;        /*    72     8 */
	char *                     _IO_backup_base;      /*    80     8 */
	char *                     _IO_save_end;         /*    88     8 */
	class _IO_marker *         _markers;             /*    96     8 */
	class _IO_FILE *           _chain;               /*   104     8 */
	int                        _fileno;              /*   112     4 */
	int                        _flags2;              /*   116     4 */
	__off_t                    _old_offset;          /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	short unsigned int         _cur_column;          /*   128     2 */
	signed char                _vtable_offset;       /*   130     1 */
	char                       _shortbuf[1];         /*   131     1 */

	/* XXX 4 bytes hole, try to pack */

	_IO_lock_t *               _lock;                /*   136     8 */
	__off64_t                  _offset;              /*   144     8 */
	void *                     __pad1;               /*   152     8 */
	void *                     __pad2;               /*   160     8 */
	void *                     __pad3;               /*   168     8 */
	void *                     __pad4;               /*   176     8 */
	size_t                     __pad5;               /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        _mode;                /*   192     4 */
	char                       _unused2[20];         /*   196    20 */

	/* size: 216, cachelines: 4, members: 29 */
	/* sum members: 208, holes: 2, sum holes: 8 */
	/* last cacheline: 24 bytes */
};
struct typedef __va_list_tag __va_list_tag {
	unsigned int               gp_offset;            /*     0     4 */
	unsigned int               fp_offset;            /*     4     4 */
	void *                     overflow_arg_area;    /*     8     8 */
	void *                     reg_save_area;        /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
typedef struct {
	typedef union {
		unsigned int               __wch;                /*           4 */
		char                       __wchb[4];            /*           4 */
	} __mbstate_t;

	int                        __count;              /*     0     4 */
	union {
		unsigned int       __wch;                /*           4 */
		char               __wchb[4];            /*           4 */
	} __value;                                       /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
} __mbstate_t;
struct tm {
	int                        tm_sec;               /*     0     4 */
	int                        tm_min;               /*     4     4 */
	int                        tm_hour;              /*     8     4 */
	int                        tm_mday;              /*    12     4 */
	int                        tm_mon;               /*    16     4 */
	int                        tm_year;              /*    20     4 */
	int                        tm_wday;              /*    24     4 */
	int                        tm_yday;              /*    28     4 */
	int                        tm_isdst;             /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	long int                   tm_gmtoff;            /*    40     8 */
	const char  *              tm_zone;              /*    48     8 */

	/* size: 56, cachelines: 1, members: 11 */
	/* sum members: 52, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct lconv {
	char *                     decimal_point;        /*     0     8 */
	char *                     thousands_sep;        /*     8     8 */
	char *                     grouping;             /*    16     8 */
	char *                     int_curr_symbol;      /*    24     8 */
	char *                     currency_symbol;      /*    32     8 */
	char *                     mon_decimal_point;    /*    40     8 */
	char *                     mon_thousands_sep;    /*    48     8 */
	char *                     mon_grouping;         /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     positive_sign;        /*    64     8 */
	char *                     negative_sign;        /*    72     8 */
	char                       int_frac_digits;      /*    80     1 */
	char                       frac_digits;          /*    81     1 */
	char                       p_cs_precedes;        /*    82     1 */
	char                       p_sep_by_space;       /*    83     1 */
	char                       n_cs_precedes;        /*    84     1 */
	char                       n_sep_by_space;       /*    85     1 */
	char                       p_sign_posn;          /*    86     1 */
	char                       n_sign_posn;          /*    87     1 */
	char                       int_p_cs_precedes;    /*    88     1 */
	char                       int_p_sep_by_space;   /*    89     1 */
	char                       int_n_cs_precedes;    /*    90     1 */
	char                       int_n_sep_by_space;   /*    91     1 */
	char                       int_p_sign_posn;      /*    92     1 */
	char                       int_n_sign_posn;      /*    93     1 */

	/* size: 96, cachelines: 2, members: 24 */
	/* padding: 2 */
	/* last cacheline: 32 bytes */
};
typedef struct {
	__off_t                    __pos;                /*     0     8 */
	__mbstate_t                __state;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
} _G_fpos_t;
struct _IO_marker {
	class _IO_marker *         _next;                /*     0     8 */
	class _IO_FILE *           _sbuf;                /*     8     8 */
	int                        _pos;                 /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
typedef struct {
	int                        quot;                 /*     0     4 */
	int                        rem;                  /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
} div_t;
typedef struct {
	long int                   quot;                 /*     0     8 */
	long int                   rem;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
} ldiv_t;
typedef struct {
	long long int              quot;                 /*     0     8 */
	long long int              rem;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
} lldiv_t;
class RtError : public exception {
	enum Type {
		WARNING = 0,
		DEBUG_WARNING = 1,
		UNSPECIFIED = 2,
		NO_DEVICES_FOUND = 3,
		INVALID_DEVICE = 4,
		MEMORY_ERROR = 5,
		INVALID_PARAMETER = 6,
		INVALID_USE = 7,
		DRIVER_ERROR = 8,
		SYSTEM_ERROR = 9,
		THREAD_ERROR = 10,
	};

public:

	/* class exception           <ancestor>; */      /*     0     0 */

	/* XXX 8 bytes hole, try to pack */
protected:


	string                     message_;             /*     8     8 */
	enum Type                  type_;                /*    16     4 */
public:

	void RtError(class RtError *, const string  &, enum Type);

	virtual void ~RtError(class RtError *, int);

	virtual void printMessage(const class RtError  *);

	virtual const enum Type  & getType(const class RtError  *);

	/* tag__fprintf: const_type tag not supported! */;

	virtual const string  & getMessage(const class RtError  *);

	virtual const char  * what(const class RtError  *);

	/* vtable has 4 entries: {
	   [3] = printMessage((null)), 
	   [4] = getType((null)), 
	   [5] = getMessage((null)), 
	   [2] = what((null)), 
	} */
	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 12, holes: 1, sum holes: 8 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
class RtAudio {
	enum Api {
		UNSPECIFIED = 0,
		LINUX_ALSA = 1,
		LINUX_OSS = 2,
		UNIX_JACK = 3,
		MACOSX_CORE = 4,
		WINDOWS_ASIO = 5,
		WINDOWS_DS = 6,
		RTAUDIO_DUMMY = 7,
	};

	struct DeviceInfo {
		bool                       probed;               /*     0     1 */

		/* XXX 7 bytes hole, try to pack */

		string                     name;                 /*     8     8 */
		unsigned int               outputChannels;       /*    16     4 */
		unsigned int               inputChannels;        /*    20     4 */
		unsigned int               duplexChannels;       /*    24     4 */
		bool                       isDefaultOutput;      /*    28     1 */
		bool                       isDefaultInput;       /*    29     1 */

		/* XXX 2 bytes hole, try to pack */

		class vector<unsigned int, std::allocator<unsigned int> > sampleRates; /*    32    24 */
		RtAudioFormat              nativeFormats;        /*    56     8 */
		void DeviceInfo(class DeviceInfo *);

		/* --- cacheline 1 boundary (64 bytes) --- */

		/* size: 64, cachelines: 1, members: 9 */
		/* sum members: 55, holes: 2, sum holes: 9 */
	};

	struct StreamParameters {
		unsigned int               deviceId;             /*     0     4 */
		unsigned int               nChannels;            /*     4     4 */
		unsigned int               firstChannel;         /*     8     4 */
		void StreamParameters(class StreamParameters *);


		/* size: 12, cachelines: 1, members: 3 */
		/* last cacheline: 12 bytes */
	};

	struct StreamOptions {
		RtAudioStreamFlags         flags;                /*     0     4 */
		unsigned int               numberOfBuffers;      /*     4     4 */
		string                     streamName;           /*     8     8 */
		int                        priority;             /*    16     4 */
		void StreamOptions(class StreamOptions *);


		/* size: 24, cachelines: 1, members: 4 */
		/* padding: 4 */
		/* last cacheline: 24 bytes */
	};

protected:

	class RtApi *              rtapi_;               /*     0     8 */
public:

	void getCompiledApi(class vector<RtAudio::Api, std::allocator<RtAudio::Api> > &);

	void RtAudio(class RtAudio *, enum Api);

	void ~RtAudio(class RtAudio *, int);

	enum Api getCurrentApi(class RtAudio *);

	unsigned int getDeviceCount(class RtAudio *);

	class DeviceInfo getDeviceInfo(class RtAudio *, unsigned int);

	unsigned int getDefaultOutputDevice(class RtAudio *);

	unsigned int getDefaultInputDevice(class RtAudio *);

	void openStream(class RtAudio *, class StreamParameters *, class StreamParameters *, RtAudioFormat, unsigned int, unsigned int *, RtAudioCallback, void *, class StreamOptions *);

	void closeStream(class RtAudio *);

	void startStream(class RtAudio *);

	void stopStream(class RtAudio *);

	void abortStream(class RtAudio *);

	bool isStreamOpen(const class RtAudio  *);

	bool isStreamRunning(const class RtAudio  *);

	double getStreamTime(class RtAudio *);

	long int getStreamLatency(class RtAudio *);

	unsigned int getStreamSampleRate(class RtAudio *);

	void showWarnings(class RtAudio *, bool);

protected:

	void openRtApi(class RtAudio *, enum Api);


	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
