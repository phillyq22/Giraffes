struct _IO_FILE {
	int                        _flags;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     _IO_read_ptr;         /*     8     8 */
	char *                     _IO_read_end;         /*    16     8 */
	char *                     _IO_read_base;        /*    24     8 */
	char *                     _IO_write_base;       /*    32     8 */
	char *                     _IO_write_ptr;        /*    40     8 */
	char *                     _IO_write_end;        /*    48     8 */
	char *                     _IO_buf_base;         /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     _IO_buf_end;          /*    64     8 */
	char *                     _IO_save_base;        /*    72     8 */
	char *                     _IO_backup_base;      /*    80     8 */
	char *                     _IO_save_end;         /*    88     8 */
	class _IO_marker *         _markers;             /*    96     8 */
	class _IO_FILE *           _chain;               /*   104     8 */
	int                        _fileno;              /*   112     4 */
	int                        _flags2;              /*   116     4 */
	__off_t                    _old_offset;          /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	short unsigned int         _cur_column;          /*   128     2 */
	signed char                _vtable_offset;       /*   130     1 */
	char                       _shortbuf[1];         /*   131     1 */

	/* XXX 4 bytes hole, try to pack */

	_IO_lock_t *               _lock;                /*   136     8 */
	__off64_t                  _offset;              /*   144     8 */
	void *                     __pad1;               /*   152     8 */
	void *                     __pad2;               /*   160     8 */
	void *                     __pad3;               /*   168     8 */
	void *                     __pad4;               /*   176     8 */
	size_t                     __pad5;               /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        _mode;                /*   192     4 */
	char                       _unused2[20];         /*   196    20 */

	/* size: 216, cachelines: 4, members: 29 */
	/* sum members: 208, holes: 2, sum holes: 8 */
	/* last cacheline: 24 bytes */
};
struct typedef __va_list_tag __va_list_tag {
	unsigned int               gp_offset;            /*     0     4 */
	unsigned int               fp_offset;            /*     4     4 */
	void *                     overflow_arg_area;    /*     8     8 */
	void *                     reg_save_area;        /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
typedef struct {
	typedef union {
		unsigned int               __wch;                /*           4 */
		char                       __wchb[4];            /*           4 */
	} __mbstate_t;

	int                        __count;              /*     0     4 */
	union {
		unsigned int       __wch;                /*           4 */
		char               __wchb[4];            /*           4 */
	} __value;                                       /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
} __mbstate_t;
struct tm {
	int                        tm_sec;               /*     0     4 */
	int                        tm_min;               /*     4     4 */
	int                        tm_hour;              /*     8     4 */
	int                        tm_mday;              /*    12     4 */
	int                        tm_mon;               /*    16     4 */
	int                        tm_year;              /*    20     4 */
	int                        tm_wday;              /*    24     4 */
	int                        tm_yday;              /*    28     4 */
	int                        tm_isdst;             /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	long int                   tm_gmtoff;            /*    40     8 */
	const char  *              tm_zone;              /*    48     8 */

	/* size: 56, cachelines: 1, members: 11 */
	/* sum members: 52, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct lconv {
	char *                     decimal_point;        /*     0     8 */
	char *                     thousands_sep;        /*     8     8 */
	char *                     grouping;             /*    16     8 */
	char *                     int_curr_symbol;      /*    24     8 */
	char *                     currency_symbol;      /*    32     8 */
	char *                     mon_decimal_point;    /*    40     8 */
	char *                     mon_thousands_sep;    /*    48     8 */
	char *                     mon_grouping;         /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     positive_sign;        /*    64     8 */
	char *                     negative_sign;        /*    72     8 */
	char                       int_frac_digits;      /*    80     1 */
	char                       frac_digits;          /*    81     1 */
	char                       p_cs_precedes;        /*    82     1 */
	char                       p_sep_by_space;       /*    83     1 */
	char                       n_cs_precedes;        /*    84     1 */
	char                       n_sep_by_space;       /*    85     1 */
	char                       p_sign_posn;          /*    86     1 */
	char                       n_sign_posn;          /*    87     1 */
	char                       int_p_cs_precedes;    /*    88     1 */
	char                       int_p_sep_by_space;   /*    89     1 */
	char                       int_n_cs_precedes;    /*    90     1 */
	char                       int_n_sep_by_space;   /*    91     1 */
	char                       int_p_sign_posn;      /*    92     1 */
	char                       int_n_sign_posn;      /*    93     1 */

	/* size: 96, cachelines: 2, members: 24 */
	/* padding: 2 */
	/* last cacheline: 32 bytes */
};
typedef struct {
	__off_t                    __pos;                /*     0     8 */
	__mbstate_t                __state;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
} _G_fpos_t;
struct _IO_marker {
	class _IO_marker *         _next;                /*     0     8 */
	class _IO_FILE *           _sbuf;                /*     8     8 */
	int                        _pos;                 /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
typedef struct {
	int                        quot;                 /*     0     4 */
	int                        rem;                  /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
} div_t;
typedef struct {
	long int                   quot;                 /*     0     8 */
	long int                   rem;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
} ldiv_t;
typedef struct {
	long long int              quot;                 /*     0     8 */
	long long int              rem;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
} lldiv_t;
class maxiOsc {
	double                     frequency;            /*     0     8 */
	double                     phase;                /*     8     8 */
	double                     startphase;           /*    16     8 */
	double                     endphase;             /*    24     8 */
	double                     output;               /*    32     8 */
	double                     tri;                  /*    40     8 */
public:

	void maxiOsc(class maxiOsc *);

	double sinewave(class maxiOsc *, double);

	double coswave(class maxiOsc *, double);

	double phasor(class maxiOsc *, double);

	double phasor(class maxiOsc *, double, double, double);

	double saw(class maxiOsc *, double);

	double triangle(class maxiOsc *, double);

	double square(class maxiOsc *, double);

	double pulse(class maxiOsc *, double, double);

	double noise(class maxiOsc *);

	double sinebuf(class maxiOsc *, double);

	double sinebuf4(class maxiOsc *, double);

	double sawn(class maxiOsc *, double);

	double rect(class maxiOsc *, double, double);

	void phaseReset(class maxiOsc *, double);


	/* size: 48, cachelines: 1, members: 6 */
	/* last cacheline: 48 bytes */
};
typedef struct {
	typedef union {
		unsigned int               __wch;                /*           4 */
		char                       __wchb[4];            /*           4 */
	} __mbstate_t;

	int                        __count;              /*     0     4 */
	union {
		unsigned int       __wch;                /*           4 */
		char               __wchb[4];            /*           4 */
	} __value;                                       /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
} __mbstate_t;
struct __pthread_internal_list {
	class __pthread_internal_list * __prev;          /*     0     8 */
	class __pthread_internal_list * __next;          /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
typedef struct {
	__off_t                    __pos;                /*     0     8 */
	__mbstate_t                __state;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
} _G_fpos_t;
typedef struct {
	int                        quot;                 /*     0     4 */
	int                        rem;                  /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
} div_t;
typedef struct {
	long int                   quot;                 /*     0     8 */
	long int                   rem;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
} ldiv_t;
typedef struct {
	long long int              quot;                 /*     0     8 */
	long long int              rem;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
} lldiv_t;
class maxiSettings {
public:

	int                        sampleRate;           /*     0     4 */
	int                        channels;             /*     0     4 */
	int                        bufferSize;           /*     0     4 */
	void setup(int, int, int);


	/* size: 1, cachelines: 1, members: 3 */
	/* padding: 65533 */
	/* last cacheline: 1 bytes */

	/* BRAIN FART ALERT! 1 != 4 + 0(holes), diff = -3 */

};
class maxiEnvelope {
	double                     period;               /*     0     8 */
	double                     output;               /*     8     8 */
	double                     phase;                /*    16     8 */
	double                     startVal;             /*    24     8 */
	double                     endVal;               /*    32     8 */
	double                     currentval;           /*    40     8 */
	double                     nextval;              /*    48     8 */
	bool                       noteOn;               /*    56     1 */
	bool                       releaseMode;          /*    57     1 */
	bool                       decayMode;            /*    58     1 */
	bool                       sustainMode;          /*    59     1 */
	bool                       attackMode;           /*    60     1 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        isPlaying;            /*    64     4 */
public:

	int                        trig;                 /*    68     4 */
	int                        valindex;             /*    72     4 */

	/* XXX 4 bytes hole, try to pack */

	double                     amplitude;            /*    80     8 */
	double line(class maxiEnvelope *, int, double *);

	double ramp(class maxiEnvelope *, double, double, double);

	double ramps(class maxiEnvelope *, class vector<double, std::allocator<double> >);

	double ar(class maxiEnvelope *, double, double);

	double adsr(class maxiEnvelope *, double, double, double, double);

	void trigger(class maxiEnvelope *, int, double);

	void trigger(class maxiEnvelope *, bool);


	/* size: 88, cachelines: 2, members: 16 */
	/* sum members: 81, holes: 2, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
class maxiDelayline {
	double                     frequency;            /*     0     8 */
	int                        phase;                /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	double                     startphase;           /*    16     8 */
	double                     endphase;             /*    24     8 */
	double                     output;               /*    32     8 */
	double                     memory[88200];        /*    40 705600 */
public:

	void maxiDelayline(class maxiDelayline *);

	double dl(class maxiDelayline *, double, int, double);

	double dl(class maxiDelayline *, double, int, double, int);

	/* --- cacheline 11025 boundary (705600 bytes) was 40 bytes ago --- */

	/* size: 705640, cachelines: 11026, members: 6 */
	/* sum members: 705636, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
class maxiFractionalDelay {
	intconst                   delaySize;            /*     0     4 */
	double                     memory[88200];        /*     0 705600 */
	int                        writePointer;         /*     0     4 */
	int                        readPointer;          /*     0     4 */
public:

	void maxiFractionalDelay(class maxiFractionalDelay *);

	double dl(class maxiFractionalDelay *, double, double, double);


	/* size: 705608, cachelines: 11026, members: 4 */
	/* padding: 50244 */
	/* last cacheline: 8 bytes */

	/* BRAIN FART ALERT! 705608 != 4 + 0(holes), diff = 705604 */

};
class maxiFilter {
	double                     gain;                 /*     0     8 */
	double                     input;                /*     8     8 */
	double                     output;               /*    16     8 */
	double                     inputs[10];           /*    24    80 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	double                     outputs[10];          /*   104    80 */
	/* --- cacheline 2 boundary (128 bytes) was 56 bytes ago --- */
	double                     cutoff1;              /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	double                     x;                    /*   192     8 */
	double                     y;                    /*   200     8 */
	double                     z;                    /*   208     8 */
	double                     c;                    /*   216     8 */
public:

	double                     cutoff;               /*   224     8 */
	double                     resonance;            /*   232     8 */
	void maxiFilter(class maxiFilter *);

	double lores(class maxiFilter *, double, double, double);

	double hires(class maxiFilter *, double, double, double);

	double bandpass(class maxiFilter *, double, double, double);

	double lopass(class maxiFilter *, double, double);

	double hipass(class maxiFilter *, double, double);


	/* size: 240, cachelines: 4, members: 12 */
	/* last cacheline: 48 bytes */
};
class maxiMix {
	double                     input;                /*     0     8 */
	double                     two[2];               /*     8    16 */
	double                     four[4];              /*    24    32 */
	double                     eight[8];             /*    56    64 */
public:

	/* --- cacheline 1 boundary (64 bytes) was 56 bytes ago --- */
	double                     x;                    /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	double                     y;                    /*   128     8 */
	double                     z;                    /*   136     8 */
	double * stereo(class maxiMix *, double, double *, double);

	double * quad(class maxiMix *, double, double *, double, double);

	double * ambisonic(class maxiMix *, double, double *, double, double, double);


	/* size: 144, cachelines: 3, members: 7 */
	/* last cacheline: 16 bytes */
};
class maxiLagExp<double> {
public:

	double                     alpha;                /*     0     8 */
	double                     alphaReciprocal;      /*     8     8 */
	double                     val;                  /*    16     8 */
	void maxiLagExp(class maxiLagExp<double> *);

	void maxiLagExp(class maxiLagExp<double> *, double, double);

	void init(class maxiLagExp<double> *, double, double);

	void addSample(class maxiLagExp<double> *, double);

	double value(class maxiLagExp<double> *);


	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
class maxiSample {
	string                     myPath;               /*     0     8 */
	int                        myChunkSize;          /*     8     4 */
	int                        mySubChunk1Size;      /*    12     4 */
	int                        readChannel;          /*    16     4 */
	short int                  myFormat;             /*    20     2 */

	/* XXX 2 bytes hole, try to pack */

	int                        myByteRate;           /*    24     4 */
	short int                  myBlockAlign;         /*    28     2 */

	/* XXX 2 bytes hole, try to pack */

	double                     position;             /*    32     8 */
	double                     recordPosition;       /*    40     8 */
	double                     speed;                /*    48     8 */
	double                     output;               /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	class maxiLagExp<double>  loopRecordLag;         /*    64    24 */
public:

	int                        myDataSize;           /*    88     4 */
	short int                  myChannels;           /*    92     2 */

	/* XXX 2 bytes hole, try to pack */

	int                        mySampleRate;         /*    96     4 */

	/* XXX 4 bytes hole, try to pack */

	long int                   length;               /*   104     8 */
	short int                  myBitsPerSample;      /*   112     2 */

	/* XXX 6 bytes hole, try to pack */

	short int *                temp;                 /*   120     8 */
	long int getLength(class maxiSample *);

	void setLength(class maxiSample *, long unsigned int);

	void ~maxiSample(class maxiSample *, int);

	void maxiSample(class maxiSample *);

	class maxiSample & operator=(class maxiSample *, const class maxiSample  &);

	bool load(class maxiSample *, string, int);

	bool loadOgg(class maxiSample *, string, int);

	void trigger(class maxiSample *);

	bool read(class maxiSample *);

	bool readOgg(class maxiSample *);

	void loopRecord(class maxiSample *, double, bool, double, double, double);

	void clear(class maxiSample *);

	void reset(class maxiSample *);

	double play(class maxiSample *);

	double playLoop(class maxiSample *, double, double);

	double playOnce(class maxiSample *);

	double playOnce(class maxiSample *, double);

	void setPosition(class maxiSample *, double);

	double playUntil(class maxiSample *, double);

	double play(class maxiSample *, double);

	double play(class maxiSample *, double, double, double, double &);

	double play(class maxiSample *, double, double, double);

	double play4(class maxiSample *, double, double, double);

	double bufferPlay(class maxiSample *, unsigned char &, long int);

	double bufferPlay(class maxiSample *, unsigned char &, double, long int);

	double bufferPlay(class maxiSample *, unsigned char &, double, double, double);

	double bufferPlay4(class maxiSample *, unsigned char &, double, double, double);

	bool save(class maxiSample *);

	bool save(class maxiSample *, string);

	char * getSummary(class maxiSample *);

	void normalise(class maxiSample *, float);

	void autoTrim(class maxiSample *, float, float, bool, bool);

	/* --- cacheline 2 boundary (128 bytes) --- */

	/* size: 128, cachelines: 2, members: 18 */
	/* sum members: 112, holes: 5, sum holes: 16 */
};
class maxiMap {
public:

	double linlin(double, double, double, double, double);

	double linexp(double, double, double, double, double);

	double explin(double, double, double, double, double);

	double clamp<double>(double, double, double);


	/* size: 0, cachelines: 0, members: 0 */
	/* last cacheline: 1 bytes */
};
class maxiDyn {
public:

	double                     input;                /*     0     8 */
	double                     ratio;                /*     8     8 */
	double                     currentRatio;         /*    16     8 */
	double                     threshold;            /*    24     8 */
	double                     output;               /*    32     8 */
	double                     attack;               /*    40     8 */
	double                     release;              /*    48     8 */
	double                     amplitude;            /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	long int                   holdtime;             /*    64     8 */
	long int                   holdcount;            /*    72     8 */
	int                        attackphase;          /*    80     4 */
	int                        holdphase;            /*    84     4 */
	int                        releasephase;         /*    88     4 */
	double gate(class maxiDyn *, double, double, long int, double, double);

	double compressor(class maxiDyn *, double, double, double, double, double);

	double compress(class maxiDyn *, double);

	void setAttack(class maxiDyn *, double);

	void setRelease(class maxiDyn *, double);

	void setThreshold(class maxiDyn *, double);

	void setRatio(class maxiDyn *, double);


	/* size: 96, cachelines: 2, members: 13 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
class maxiEnv {
public:

	double                     input;                /*     0     8 */
	double                     output;               /*     8     8 */
	double                     attack;               /*    16     8 */
	double                     decay;                /*    24     8 */
	double                     sustain;              /*    32     8 */
	double                     release;              /*    40     8 */
	double                     amplitude;            /*    48     8 */
	int                        trigger;              /*    56     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	long int                   holdtime;             /*    64     8 */
	long int                   holdcount;            /*    72     8 */
	int                        attackphase;          /*    80     4 */
	int                        decayphase;           /*    84     4 */
	int                        sustainphase;         /*    88     4 */
	int                        holdphase;            /*    92     4 */
	int                        releasephase;         /*    96     4 */
	double ar(class maxiEnv *, double, double, double, long int, int);

	double adsr(class maxiEnv *, double, double, double, double, double, long int, int);

	double adsr(class maxiEnv *, double, int);

	void setAttack(class maxiEnv *, double);

	void setRelease(class maxiEnv *, double);

	void setDecay(class maxiEnv *, double);

	void setSustain(class maxiEnv *, double);

	void maxiEnv(class maxiEnv *);


	/* size: 104, cachelines: 2, members: 15 */
	/* sum members: 96, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
class convert {
public:

	double mtof(int);

	int ftom(double);

	double atodb(double);

	double dbtoa(double);


	/* size: 0, cachelines: 0, members: 0 */
	/* last cacheline: 1 bytes */
};
class maxiDistortion {
public:

	double atanDist(class maxiDistortion *, double, double);

	double fastAtanDist(class maxiDistortion *, double, double);

	double fastatan(class maxiDistortion *, double);


	/* size: 0, cachelines: 0, members: 0 */
	/* last cacheline: 1 bytes */
};
class maxiEnvelopeFollowerType<double> {
	double                     attack;               /*     0     8 */
	double                     release;              /*     8     8 */
	double                     env;                  /*    16     8 */
public:

	void maxiEnvelopeFollowerType(class maxiEnvelopeFollowerType<double> *);

	void setAttack(class maxiEnvelopeFollowerType<double> *, double);

	void setRelease(class maxiEnvelopeFollowerType<double> *, double);

	double play(class maxiEnvelopeFollowerType<double> *, double);

	void reset(class maxiEnvelopeFollowerType<double> *);

	double getEnv(class maxiEnvelopeFollowerType<double> *);

	void setEnv(class maxiEnvelopeFollowerType<double> *, double);


	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
class maxiSVF {
	double                     v0z;                  /*     0     8 */
	double                     v1;                   /*     8     8 */
	double                     v2;                   /*    16     8 */
	double                     g;                    /*    24     8 */
	double                     damping;              /*    32     8 */
	double                     k;                    /*    40     8 */
	double                     ginv;                 /*    48     8 */
	double                     g1;                   /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	double                     g2;                   /*    64     8 */
	double                     g3;                   /*    72     8 */
	double                     g4;                   /*    80     8 */
	double                     freq;                 /*    88     8 */
	double                     res;                  /*    96     8 */
public:

	void maxiSVF(class maxiSVF *);

	class maxiSVF & setCutoff(class maxiSVF *, double);

	class maxiSVF & setResonance(class maxiSVF *, double);

	double play(class maxiSVF *, double, double, double, double, double);

	void setParams(class maxiSVF *, double, double);


	/* size: 104, cachelines: 2, members: 13 */
	/* last cacheline: 40 bytes */
};
class maxiKick {
public:

	double                     pitch;                /*     0     8 */
	double                     output;               /*     8     8 */
	double                     outputD;              /*    16     8 */
	double                     envOut;               /*    24     8 */
	bool                       useDistortion;        /*    32     1 */
	bool                       useLimiter;           /*    33     1 */
	bool                       useFilter;            /*    34     1 */

	/* XXX 5 bytes hole, try to pack */

	double                     distortion;           /*    40     8 */
	bool                       inverse;              /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	double                     cutoff;               /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	double                     resonance;            /*    64     8 */
	double                     gain;                 /*    72     8 */
	class maxiOsc             kick;                  /*    80    48 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	class maxiEnv             envelope;              /*   128   104 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 3 boundary (192 bytes) was 40 bytes ago --- */
	class maxiDistortion      distort;               /*   232     0 */

	/* XXX 8 bytes hole, try to pack */

	class maxiFilter          filter;                /*   240   240 */
	void maxiKick(class maxiKick *);

	double play(class maxiKick *);

	void setPitch(class maxiKick *, double);

	void setRelease(class maxiKick *, double);

	void trigger(class maxiKick *);

	/* --- cacheline 7 boundary (448 bytes) was 32 bytes ago --- */

	/* size: 480, cachelines: 8, members: 16 */
	/* sum members: 460, holes: 3, sum holes: 20 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 32 bytes */
};
class maxiSnare {
public:

	double                     pitch;                /*     0     8 */
	double                     output;               /*     8     8 */
	double                     outputD;              /*    16     8 */
	double                     envOut;               /*    24     8 */
	bool                       useDistortion;        /*    32     1 */
	bool                       useLimiter;           /*    33     1 */
	bool                       useFilter;            /*    34     1 */

	/* XXX 5 bytes hole, try to pack */

	double                     distortion;           /*    40     8 */
	bool                       inverse;              /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	double                     cutoff;               /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	double                     resonance;            /*    64     8 */
	double                     gain;                 /*    72     8 */
	class maxiOsc             tone;                  /*    80    48 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	class maxiOsc             noise;                 /*   128    48 */
	class maxiEnv             envelope;              /*   176   104 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 4 boundary (256 bytes) was 24 bytes ago --- */
	class maxiDistortion      distort;               /*   280     0 */

	/* XXX 8 bytes hole, try to pack */

	class maxiFilter          filter;                /*   288   240 */
	void maxiSnare(class maxiSnare *);

	double play(class maxiSnare *);

	void setPitch(class maxiSnare *, double);

	void setRelease(class maxiSnare *, double);

	void trigger(class maxiSnare *);

	/* --- cacheline 8 boundary (512 bytes) was 16 bytes ago --- */

	/* size: 528, cachelines: 9, members: 17 */
	/* sum members: 508, holes: 3, sum holes: 20 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 16 bytes */
};
class maxiHats {
public:

	double                     pitch;                /*     0     8 */
	double                     output;               /*     8     8 */
	double                     outputD;              /*    16     8 */
	double                     envOut;               /*    24     8 */
	bool                       useDistortion;        /*    32     1 */
	bool                       useLimiter;           /*    33     1 */
	bool                       useFilter;            /*    34     1 */

	/* XXX 5 bytes hole, try to pack */

	double                     distortion;           /*    40     8 */
	bool                       inverse;              /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	double                     cutoff;               /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	double                     resonance;            /*    64     8 */
	double                     gain;                 /*    72     8 */
	class maxiOsc             tone;                  /*    80    48 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	class maxiOsc             noise;                 /*   128    48 */
	class maxiEnv             envelope;              /*   176   104 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 4 boundary (256 bytes) was 24 bytes ago --- */
	class maxiDistortion      distort;               /*   280     0 */

	/* XXX 8 bytes hole, try to pack */

	class maxiSVF             filter;                /*   288   104 */
	void maxiHats(class maxiHats *);

	double play(class maxiHats *);

	void setPitch(class maxiHats *, double);

	void setRelease(class maxiHats *, double);

	void trigger(class maxiHats *);

	/* --- cacheline 6 boundary (384 bytes) was 8 bytes ago --- */

	/* size: 392, cachelines: 7, members: 17 */
	/* sum members: 372, holes: 3, sum holes: 20 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 8 bytes */
};
class maxiSampler {
public:

	double                     position;             /*     0     8 */
	double                     pitch[32];            /*     8   256 */
	/* --- cacheline 4 boundary (256 bytes) was 8 bytes ago --- */
	int                        originalPitch;        /*   264     4 */

	/* XXX 4 bytes hole, try to pack */

	double                     outputs[32];          /*   272   256 */
	/* --- cacheline 8 boundary (512 bytes) was 16 bytes ago --- */
	double                     outputD;              /*   528     8 */
	double                     envOut[32];           /*   536   256 */
	/* --- cacheline 12 boundary (768 bytes) was 24 bytes ago --- */
	double                     envOutGain[32];       /*   792   256 */
	/* --- cacheline 16 boundary (1024 bytes) was 24 bytes ago --- */
	double                     output;               /*  1048     8 */
	bool                       useDistortion;        /*  1056     1 */
	bool                       useLimiter;           /*  1057     1 */
	bool                       useFilter;            /*  1058     1 */

	/* XXX 5 bytes hole, try to pack */

	double                     distortion;           /*  1064     8 */
	bool                       inverse;              /*  1072     1 */

	/* XXX 7 bytes hole, try to pack */

	double                     cutoff;               /*  1080     8 */
	/* --- cacheline 17 boundary (1088 bytes) --- */
	double                     resonance;            /*  1088     8 */
	double                     gain;                 /*  1096     8 */
	int                        voices;               /*  1104     4 */
	int                        currentVoice;         /*  1108     4 */
	class convert             mtof;                  /*  1112     0 */

	/* XXX 8 bytes hole, try to pack */

	class maxiOsc             LFO1;                  /*  1120    48 */
	/* --- cacheline 18 boundary (1152 bytes) was 16 bytes ago --- */
	class maxiOsc             LFO2;                  /*  1168    48 */
	/* --- cacheline 19 boundary (1216 bytes) --- */
	class maxiOsc             LFO3;                  /*  1216    48 */
	class maxiOsc             LFO4;                  /*  1264    48 */
	/* --- cacheline 20 boundary (1280 bytes) was 32 bytes ago --- */
	class maxiSample          samples[32];           /*  1312  4096 */
	/* --- cacheline 84 boundary (5376 bytes) was 32 bytes ago --- */
	class maxiEnv             envelopes[32];         /*  5408  3328 */
	/* --- cacheline 136 boundary (8704 bytes) was 32 bytes ago --- */
	class maxiDistortion      distort;               /*  8736     0 */

	/* XXX 8 bytes hole, try to pack */

	class maxiSVF             filters[32];           /*  8744  3328 */
	/* --- cacheline 188 boundary (12032 bytes) was 40 bytes ago --- */
	bool                       sustain;              /* 12072     1 */
	void maxiSampler(class maxiSampler *);

	double play(class maxiSampler *);

	void setPitch(class maxiSampler *, double, bool);

	void midiNoteOn(class maxiSampler *, double, double, bool);

	void midiNoteOff(class maxiSampler *, double, double, bool);

	void setAttack(class maxiSampler *, double, bool);

	void setDecay(class maxiSampler *, double, bool);

	void setSustain(class maxiSampler *, double, bool);

	void setRelease(class maxiSampler *, double, bool);

	void setPosition(class maxiSampler *, double, bool);

	void load(class maxiSampler *, string, bool);

	void setNumVoices(class maxiSampler *, int);

	void trigger(class maxiSampler *);


	/* size: 12080, cachelines: 189, members: 28 */
	/* sum members: 12041, holes: 5, sum holes: 32 */
	/* padding: 7 */
	/* last cacheline: 48 bytes */
};
class maxiClock {
public:

	class maxiOsc             timer;                 /*     0    48 */
	int                        currentCount;         /*    48     4 */
	int                        lastCount;            /*    52     4 */
	int                        playHead;             /*    56     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	double                     bps;                  /*    64     8 */
	double                     bpm;                  /*    72     8 */
	int                        ticks;                /*    80     4 */
	bool                       tick;                 /*    84     1 */
	void maxiClock(class maxiClock *);

	void ticker(class maxiClock *);

	void setTempo(class maxiClock *, double);

	void setTicksPerBeat(class maxiClock *, int);


	/* size: 88, cachelines: 2, members: 8 */
	/* sum members: 81, holes: 1, sum holes: 4 */
	/* padding: 3 */
	/* last cacheline: 24 bytes */
};
class maxiRecorder {
	bool                       threadRunning;        /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	intconst                   bufferQueueSize;      /*     4     4 */
	intconst                   bufferSize;           /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	long int                   bufferIndex;          /*    16     8 */
	long int                   recordedAmountFrames; /*    24     8 */
	class queue<double*, std::deque<double*, std::allocator<double*> > > bufferQueue; /*    32    80 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	class queue<double*, std::deque<double*, std::allocator<double*> > > savedBuffers; /*   112    80 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	bool                       doRecord;             /*   192     1 */

	/* XXX 7 bytes hole, try to pack */

	string                     filename;             /*   200     8 */
	pthread_t                  daemon;               /*   208     8 */
public:

	void maxiRecorder(class maxiRecorder *);

	void ~maxiRecorder(class maxiRecorder *, int);

	void setup(class maxiRecorder *, string);

	void startRecording(class maxiRecorder *);

	void stopRecording(class maxiRecorder *);

	bool isRecording(const class maxiRecorder  *);

	void passData(class maxiRecorder *, double *, int);

	void passData(class maxiRecorder *, float *, int);

	void saveToWav(class maxiRecorder *);

	void * update(class maxiRecorder *, void *);

	class vector<double, std::allocator<double> > getProcessedData(class maxiRecorder *);

	void enqueueBuffer(class maxiRecorder *);

	void freeResources(class maxiRecorder *);

	void * update_pthread_helper(void *);

	void write<int>(class maxiRecorder *, ofstream &, const int  &);

	void write<short int>(class maxiRecorder *, ofstream &, const short int  &);


	/* size: 216, cachelines: 4, members: 10 */
	/* sum members: 202, holes: 3, sum holes: 14 */
	/* last cacheline: 24 bytes */
};
class maxiLagExp<float> {
public:

	float                      alpha;                /*     0     4 */
	float                      alphaReciprocal;      /*     4     4 */
	float                      val;                  /*     8     4 */
	void maxiLagExp(class maxiLagExp<float> *);

	void maxiLagExp(class maxiLagExp<float> *, float, float);

	void init(class maxiLagExp<float> *, float, float);

	void addSample(class maxiLagExp<float> *, float);

	float value(class maxiLagExp<float> *);


	/* size: 12, cachelines: 1, members: 3 */
	/* last cacheline: 12 bytes */
};
typedef struct {
	typedef union {
		unsigned int               __wch;                /*           4 */
		char                       __wchb[4];            /*           4 */
	} __mbstate_t;

	int                        __count;              /*     0     4 */
	union {
		unsigned int       __wch;                /*           4 */
		char               __wchb[4];            /*           4 */
	} __value;                                       /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
} __mbstate_t;
class RtError : public exception {
	enum Type {
		WARNING = 0,
		DEBUG_WARNING = 1,
		UNSPECIFIED = 2,
		NO_DEVICES_FOUND = 3,
		INVALID_DEVICE = 4,
		MEMORY_ERROR = 5,
		INVALID_PARAMETER = 6,
		INVALID_USE = 7,
		DRIVER_ERROR = 8,
		SYSTEM_ERROR = 9,
		THREAD_ERROR = 10,
	};

public:

	/* class exception           <ancestor>; */      /*     0     0 */

	/* XXX 8 bytes hole, try to pack */
protected:


	string                     message_;             /*     8     8 */
	enum Type                  type_;                /*    16     4 */
public:

	void RtError(class RtError *, const class RtError  &);

	void RtError(class RtError *, const string  &, enum Type);

	virtual void ~RtError(class RtError *, int);

	virtual void printMessage(const class RtError  *);

	virtual const enum Type  & getType(const class RtError  *);

	/* tag__fprintf: const_type tag not supported! */;

	virtual const string  & getMessage(const class RtError  *);

	virtual const char  * what(const class RtError  *);

	/* vtable has 4 entries: {
	   [3] = printMessage((null)), 
	   [4] = getType((null)), 
	   [5] = getMessage((null)), 
	   [2] = what((null)), 
	} */
	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 12, holes: 1, sum holes: 8 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
class RtAudio {
	enum Api {
		UNSPECIFIED = 0,
		LINUX_ALSA = 1,
		LINUX_OSS = 2,
		UNIX_JACK = 3,
		MACOSX_CORE = 4,
		WINDOWS_ASIO = 5,
		WINDOWS_DS = 6,
		RTAUDIO_DUMMY = 7,
	};

	struct DeviceInfo {
		bool                       probed;               /*     0     1 */

		/* XXX 7 bytes hole, try to pack */

		string                     name;                 /*     8     8 */
		unsigned int               outputChannels;       /*    16     4 */
		unsigned int               inputChannels;        /*    20     4 */
		unsigned int               duplexChannels;       /*    24     4 */
		bool                       isDefaultOutput;      /*    28     1 */
		bool                       isDefaultInput;       /*    29     1 */

		/* XXX 2 bytes hole, try to pack */

		class vector<unsigned int, std::allocator<unsigned int> > sampleRates; /*    32    24 */
		RtAudioFormat              nativeFormats;        /*    56     8 */
		void DeviceInfo(class DeviceInfo *);

		/* --- cacheline 1 boundary (64 bytes) --- */

		/* size: 64, cachelines: 1, members: 9 */
		/* sum members: 55, holes: 2, sum holes: 9 */
	};

	struct StreamParameters {
		unsigned int               deviceId;             /*     0     4 */
		unsigned int               nChannels;            /*     4     4 */
		unsigned int               firstChannel;         /*     8     4 */
		void StreamParameters(class StreamParameters *);


		/* size: 12, cachelines: 1, members: 3 */
		/* last cacheline: 12 bytes */
	};

	struct StreamOptions {
		RtAudioStreamFlags         flags;                /*     0     4 */
		unsigned int               numberOfBuffers;      /*     4     4 */
		string                     streamName;           /*     8     8 */
		int                        priority;             /*    16     4 */
		void StreamOptions(class StreamOptions *);


		/* size: 24, cachelines: 1, members: 4 */
		/* padding: 4 */
		/* last cacheline: 24 bytes */
	};

protected:

	class RtApi *              rtapi_;               /*     0     8 */
public:

	void getCompiledApi(class vector<RtAudio::Api, std::allocator<RtAudio::Api> > &);

	void RtAudio(class RtAudio *, enum Api);

	void ~RtAudio(class RtAudio *, int);

	enum Api getCurrentApi(class RtAudio *);

	unsigned int getDeviceCount(class RtAudio *);

	class DeviceInfo getDeviceInfo(class RtAudio *, unsigned int);

	unsigned int getDefaultOutputDevice(class RtAudio *);

	unsigned int getDefaultInputDevice(class RtAudio *);

	void openStream(class RtAudio *, class StreamParameters *, class StreamParameters *, RtAudioFormat, unsigned int, unsigned int *, RtAudioCallback, void *, class StreamOptions *);

	void closeStream(class RtAudio *);

	void startStream(class RtAudio *);

	void stopStream(class RtAudio *);

	void abortStream(class RtAudio *);

	bool isStreamOpen(const class RtAudio  *);

	bool isStreamRunning(const class RtAudio  *);

	double getStreamTime(class RtAudio *);

	long int getStreamLatency(class RtAudio *);

	unsigned int getStreamSampleRate(class RtAudio *);

	void showWarnings(class RtAudio *, bool);

protected:

	void openRtApi(class RtAudio *, enum Api);

	/* tag__fprintf: const_type tag not supported! */;


	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class RtApi {
	enum {
		FAILURE = 0,
		SUCCESS = 1,
	};

	enum StreamState {
		STREAM_STOPPED = 0,
		STREAM_RUNNING = 1,
		STREAM_CLOSED = 4294967246,
	};

	enum StreamMode {
		OUTPUT = 0,
		INPUT = 1,
		DUPLEX = 2,
		UNINITIALIZED = 4294967221,
	};

	struct ConvertInfo {
		int                        channels;             /*     0     4 */
		int                        inJump;               /*     4     4 */
		int                        outJump;              /*     8     4 */

		/* XXX 4 bytes hole, try to pack */

		RtAudioFormat              inFormat;             /*    16     8 */
		RtAudioFormat              outFormat;            /*    24     8 */
		class vector<int, std::allocator<int> > inOffset; /*    32    24 */
		class vector<int, std::allocator<int> > outOffset; /*    56    24 */
		void ConvertInfo(class ConvertInfo *);

		void ~ConvertInfo(class ConvertInfo *, int);

		/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */

		/* size: 80, cachelines: 2, members: 7 */
		/* sum members: 76, holes: 1, sum holes: 4 */
		/* last cacheline: 16 bytes */
	};

	struct RtApiStream {
		unsigned int               device[2];            /*     0     8 */
		void *                     apiHandle;            /*     8     8 */
		enum StreamMode            mode;                 /*    16     4 */
		enum StreamState           state;                /*    20     4 */
		char *                     userBuffer[2];        /*    24    16 */
		char *                     deviceBuffer;         /*    40     8 */
		bool                       doConvertBuffer[2];   /*    48     2 */
		bool                       userInterleaved;      /*    50     1 */
		bool                       deviceInterleaved[2]; /*    51     2 */
		bool                       doByteSwap[2];        /*    53     2 */

		/* XXX 1 byte hole, try to pack */

		unsigned int               sampleRate;           /*    56     4 */
		unsigned int               bufferSize;           /*    60     4 */
		/* --- cacheline 1 boundary (64 bytes) --- */
		unsigned int               nBuffers;             /*    64     4 */
		unsigned int               nUserChannels[2];     /*    68     8 */
		unsigned int               nDeviceChannels[2];   /*    76     8 */
		unsigned int               channelOffset[2];     /*    84     8 */

		/* XXX 4 bytes hole, try to pack */

		long unsigned int          latency[2];           /*    96    16 */
		RtAudioFormat              userFormat;           /*   112     8 */
		long unsigned int          deviceFormat[2];      /*   120    16 */
		/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
		StreamMutex                mutex;                /*   136     4 */

		/* XXX 4 bytes hole, try to pack */

		struct CallbackInfo        callbackInfo;         /*   144    48 */
		/* --- cacheline 3 boundary (192 bytes) --- */
		struct ConvertInfo         convertInfo[2];       /*   192   160 */
		/* --- cacheline 5 boundary (320 bytes) was 32 bytes ago --- */
		double                     streamTime;           /*   352     8 */
		void RtApiStream(class RtApiStream *);

		void ~RtApiStream(class RtApiStream *, int);


		/* size: 360, cachelines: 6, members: 23 */
		/* sum members: 351, holes: 3, sum holes: 9 */
		/* last cacheline: 40 bytes */
	};

public:

	int ()(void) * *           _vptr.RtApi;          /*     0     8 */
protected:

	unsigned intconst          MAX_SAMPLE_RATES;     /*     0     4 */
	unsigned intconst          SAMPLE_RATES;         /*     0    56 */
	ostringstream              errorStream_;         /*     8     0 */

	/* XXX 352 bytes hole, try to pack */

	/* --- cacheline 5 boundary (320 bytes) was 40 bytes ago --- */
	string                     errorText_;           /*   360     8 */
	bool                       showWarnings_;        /*   368     1 */

	/* XXX 7 bytes hole, try to pack */

	struct RtApiStream         stream_;              /*   376   360 */
	typedef short int Int16;

	typedef int Int32;

	typedef float Float32;

	typedef double Float64;

public:

	void RtApi(class RtApi *, const class RtApi  &);

	void RtApi(class RtApi *);

	virtual void ~RtApi(class RtApi *, int);

	virtual enum Api getCurrentApi(class RtApi *);

	virtual unsigned int getDeviceCount(class RtApi *);

	virtual class DeviceInfo getDeviceInfo(class RtApi *, unsigned int);

	virtual unsigned int getDefaultInputDevice(class RtApi *);

	virtual unsigned int getDefaultOutputDevice(class RtApi *);

	void openStream(class RtApi *, class StreamParameters *, class StreamParameters *, RtAudioFormat, unsigned int, unsigned int *, RtAudioCallback, void *, class StreamOptions *);

	virtual void closeStream(class RtApi *);

	virtual void startStream(class RtApi *);

	virtual void stopStream(class RtApi *);

	virtual void abortStream(class RtApi *);

	long int getStreamLatency(class RtApi *);

	unsigned int getStreamSampleRate(class RtApi *);

	virtual double getStreamTime(class RtApi *);

	bool isStreamOpen(const class RtApi  *);

	bool isStreamRunning(const class RtApi  *);

	void showWarnings(class RtApi *, bool);

protected:

	virtual bool probeDeviceOpen(class RtApi *, unsigned int, enum StreamMode, unsigned int, unsigned int, unsigned int, RtAudioFormat, unsigned int *, class StreamOptions *);

	void tickStreamTime(class RtApi *);

	void clearStreamInfo(class RtApi *);

	void verifyStream(class RtApi *);

	void error(class RtApi *, enum Type);

	void convertBuffer(class RtApi *, char *, char *, class ConvertInfo &);

	void byteSwapBuffer(class RtApi *, char *, unsigned int, RtAudioFormat);

	unsigned int formatBytes(class RtApi *, RtAudioFormat);

	void setConvertInfo(class RtApi *, enum StreamMode, unsigned int);

	/* --- cacheline 11 boundary (704 bytes) was 32 bytes ago --- */
	/* vtable has 11 entries: {
	   [2] = getCurrentApi((null)), 
	   [3] = getDeviceCount((null)), 
	   [4] = getDeviceInfo((null)), 
	   [5] = getDefaultInputDevice((null)), 
	   [6] = getDefaultOutputDevice((null)), 
	   [7] = closeStream((null)), 
	   [8] = startStream((null)), 
	   [9] = stopStream((null)), 
	   [10] = abortStream((null)), 
	   [11] = getStreamTime((null)), 
	   [12] = probeDeviceOpen((null)), 
	} */
	/* size: 736, cachelines: 12, members: 7 */
	/* sum members: 377, holes: 2, sum holes: 359 */
	/* last cacheline: 32 bytes */
};
struct CallbackInfo {
	void *                     object;               /*     0     8 */
	ThreadHandle               thread;               /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	void *                     callback;             /*    16     8 */
	void *                     userData;             /*    24     8 */
	void *                     apiInfo;              /*    32     8 */
	bool                       isRunning;            /*    40     1 */
	void CallbackInfo(class CallbackInfo *);


	/* size: 48, cachelines: 1, members: 6 */
	/* sum members: 37, holes: 1, sum holes: 4 */
	/* padding: 7 */
	/* last cacheline: 48 bytes */
};
typedef struct {
	int                        quot;                 /*     0     4 */
	int                        rem;                  /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
} div_t;
typedef struct {
	long int                   quot;                 /*     0     8 */
	long int                   rem;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
} ldiv_t;
typedef struct {
	long long int              quot;                 /*     0     8 */
	long long int              rem;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
} lldiv_t;
class RtApiDummy : public RtApi {
public:

	/* class RtApi               <ancestor>; */      /*     0   736 */
	void RtApiDummy(class RtApiDummy *, const class RtApiDummy  &);

	void RtApiDummy(class RtApiDummy *);

	virtual enum Api getCurrentApi(class RtApiDummy *);

	virtual unsigned int getDeviceCount(class RtApiDummy *);

	virtual class DeviceInfo getDeviceInfo(class RtApiDummy *, unsigned int);

	virtual void closeStream(class RtApiDummy *);

	virtual void startStream(class RtApiDummy *);

	virtual void stopStream(class RtApiDummy *);

	virtual void abortStream(class RtApiDummy *);

	virtual bool probeDeviceOpen(class RtApiDummy *, unsigned int, enum StreamMode, unsigned int, unsigned int, unsigned int, RtAudioFormat, unsigned int *, class StreamOptions *);

	virtual void ~RtApiDummy(class RtApiDummy *, int);

	/* --- cacheline 11 boundary (704 bytes) was 32 bytes ago --- */
	/* vtable has 8 entries: {
	   [2] = getCurrentApi((null)), 
	   [3] = getDeviceCount((null)), 
	   [4] = getDeviceInfo((null)), 
	   [7] = closeStream((null)), 
	   [8] = startStream((null)), 
	   [9] = stopStream((null)), 
	   [10] = abortStream((null)), 
	   [12] = probeDeviceOpen((null)), 
	} */
	/* size: 736, cachelines: 12, members: 1 */
	/* last cacheline: 32 bytes */
};
typedef struct {
	typedef union {
		unsigned int               __wch;                /*           4 */
		char                       __wchb[4];            /*           4 */
	} __mbstate_t;

	int                        __count;              /*     0     4 */
	union {
		unsigned int       __wch;                /*           4 */
		char               __wchb[4];            /*           4 */
	} __value;                                       /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
} __mbstate_t;
typedef struct {
	__off_t                    __pos;                /*     0     8 */
	__mbstate_t                __state;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
} _G_fpos_t;
typedef struct {
	int                        quot;                 /*     0     4 */
	int                        rem;                  /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
} div_t;
typedef struct {
	long int                   quot;                 /*     0     8 */
	long int                   rem;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
} ldiv_t;
typedef struct {
	long long int              quot;                 /*     0     8 */
	long long int              rem;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
} lldiv_t;
